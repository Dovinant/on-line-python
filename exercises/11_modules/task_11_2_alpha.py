# -*- coding: utf-8 -*-
'''
Задание 11.2

Создать функцию create_network_map, которая обрабатывает
вывод команды show cdp neighbors из нескольких файлов и объединяет его в одну общую топологию.

У функции должен быть один параметр filenames, который ожидает как аргумент список с именами файлов,
в которых находится вывод команды show cdp neighbors.

Функция должна возвращать словарь, который описывает соединения между устройствами.
Структура словаря такая же, как в задании 11.1:
    {('R4', 'Fa0/1'): ('R5', 'Fa0/1'),
     ('R4', 'Fa0/2'): ('R6', 'Fa0/0')}


Cгенерировать топологию, которая соответствует выводу из файлов:
* sh_cdp_n_sw1.txt
* sh_cdp_n_r1.txt
* sh_cdp_n_r2.txt
* sh_cdp_n_r3.txt

В словаре, который возвращает функция create_network_map, не должно быть дублей.

С помощью функции draw_topology из файла draw_network_graph.py нарисовать схему на основании топологии,
полученной с помощью функции create_network_map.
Результат должен выглядеть так же, как схема в файле task_11_2a_topology.svg


При этом:
* Расположение устройств на схеме может быть другим
* Соединения должны соответствовать схеме

Не копировать код функций parse_cdp_neighbors и draw_topology.

Ограничение: Все задания надо выполнять используя только пройденные темы.

> Для выполнения этого задания, должен быть установлен graphviz:
> apt-get install graphviz

> И модуль python для работы с graphviz:
> pip install graphviz (внутри виртуального окружения именно так, без sudo!!)

'''
# Импортируем функцию draw_topology
from draw_network_graph import draw_topology
# Создаём функцию
def create_network_map(filenames):
# Создаём словари. В result_right записи будут согласно заданию,
# а result_left ему зеркален: ключ будет имя удалённого устройства и его интерфейс
    result_right = {}
    result_left = {}
    for item in filenames:
        file = open(item, 'r')
# Убираем из полученой строки слева и справа '\n'.
# Или потом это придётся делать для local_host и neighbors
        command = file.read()
        command = command.strip()
# В local_host запишем имя нашего устройста. Оно будет перед '>' или '#'
# Здесь мы ищем только позицию '>' и делаем срез строки
        local_host = command[0:command.find('>')]
#    local_host.strip()
# В neighbors запишем только вывод соседей.
# Для этого ноходим номер позиции элемента 'ID\n', добавляем к нему 3
# и делаем срез строки начиная с полученной позиции.
# Срез начнётся с имени первого соседа
        neighbors = command[command.find('ID\n') + 3 ::]
# Преобразуем строку в список. Элементы разделяем по '\n'
        neighbors = neighbors.split('\n')
# В neighbors теперь список строк и каждая описывает конкретного соседа
# Дальше проходим по списку, каждую строку тоже преобразуем в список, но уже разделитель пробел
# и распаковываем переменные. Три слева и два справа: сосед, наш интерфейс, его номер,
# интерфейс соседа, его номер, объединяем имена интерфейсов с их номерами
# и, наконец, записываем всё в словарь.
        for line in neighbors:
            line = line.split()
            r_host, l_intf, l_intf_num, *other, r_intf, r_intf_num = line
            r_intf = r_intf + r_intf_num
            l_intf = l_intf + l_intf_num
            result_right[local_host, l_intf] = r_host, r_intf
            result_left[r_host, r_intf] = local_host, l_intf
            for key in result_left:
                if result_right[local_host, l_intf] == result_left[key]:
                    del(result_right[local_host, l_intf])
                    break

    return(result_right)

# Список с именами файлов
file_list = ['sh_cdp_n_sw1.txt', 'sh_cdp_n_r1.txt', 'sh_cdp_n_r2.txt', 'sh_cdp_n_r3.txt']
# Вызываем функцию. Принимаем результат в topology_dict
topology_dict = create_network_map(file_list)
# Рисуем схему
draw_topology(topology_dict)

'''
Записи в словаре дублируются когда ключ словаря и его значение меняются местами
т.е. когда в словарь помещается запись ключ-значение, а потом ещё одна запись
у которой ключ это значение нашей записи, а значение есть ключ нашей записи. Таким образом
описывается одно и тоже соединение между двумя устройствами.
Так получается когда мы последовательно обрабатываем вывод команды show cdp neighbors на соседних устройствах
Чтобы избавится от дублирования создаём два словаря: result_right и result_left. При этом словарь result_left зеркален
словарю result_rigЭht.
Дальше в цикле for key in result_left берём ключ из словаря result_right и последовательно сравниваем со всеми ключами
словаря result_left (ключи словаря result_left это, по-сути, значения словаря result_right). Совпадение говорит о том,
что в словарь result_right помещена запись описывающая уже имеющееся в нём соединение. Удаляем её.

Предложенное решение, однако, не отвечает условию задачи: нельзя в неё было копировать код из функции parse_cdp_neighbors
'''
