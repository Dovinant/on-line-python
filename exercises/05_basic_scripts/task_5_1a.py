# -*- coding: utf-8 -*-
'''
Задание 5.1a

Всё, как в задании 5.1. Но, если пользователь ввел адрес хоста, а не адрес сети,
то надо адрес хоста преобразовать в адрес сети и вывести адрес сети и маску, как в задании 5.1.

Пример адреса сети (все биты хостовой части равны нулю):
* 10.0.1.0/24
* 190.1.0.0/16

Пример адреса хоста:
* 10.0.1.1/24 - хост из сети 10.0.1.0/24
* 10.0.5.1/30 - хост из сети 10.0.5.0/30

Если пользователь ввел адрес 10.0.1.1/24,
вывод должен быть таким:

Network:
10        0         1         0
00001010  00000000  00000001  00000000

Mask:
/24
255       255       255       0
11111111  11111111  11111111  00000000

Проверить работу скрипта на разных комбинациях сеть/маска.

Ограничение: Все задания надо выполнять используя только пройденные темы.

'''
print("Please input address/mask")

# IPhyton принимате аргумент в кавычках!
NetMask = input(("For example '10.1.1.0/24': "))

# Получили адрес/маску.
# Теперь разносим маску и адрес испульзуя метод find() и срез
# См. стр. 93, 95 учебника
Net = NetMask[0:NetMask.find('/')]

# Так получим саму битовую маску, без "/"
# Если нужен "/" то NetMask[NetMask.find('/')::]
# Mask = NetMask[1+NetMask.find('/')::]

# Преобразуем строковое значение маски в цифровое
Mask = int(NetMask[1+NetMask.find('/')::])

# Согласно полученной маске создаём строку из единиц и нулей
MaskBin = ('1' * Mask + (32 - Mask) * '0')

# Далее строку преобразуем в список из восьми элементов
# Пользуемся срезами и не забываем,
# что срез идёт до второго числа НЕ ВКЛЮЧАЯ ЕГО
# см. стр. 92

MaskList = [MaskBin[0:8], MaskBin[8:16], MaskBin[16:24], MaskBin[24::]]

# Преобразуем текстовые значения в цифровые (стр. 131)

MaskList = [int(MaskList[I], 2) for I in range(4)]

# Преобразуем строку в список, элементы разделяем по точке
IP_LIST = Net.split('.')

# Преобразуем текстовые значения в цифровые

IP_LIST = [int(IP_LIST[I]) for I in range(4)]

#--------------------------------------------------------------------
# Преобразуем десятичные значения в двоичные
# Функция bin() на стр. 131 вернёт строку вида '0b1010'
# Чтобы привести её к виду '00001010' берём срез со второго символа
# и заполняем ведущими нулями, если строка меньше 8 символов

IP_LIST_BIN = [bin(IP_LIST[I])[2:].zfill(8) for I in range(4)]

# Преобразуем список в строку

IP_STR_BIN = ''.join(IP_LIST_BIN)

# Обрезаем строку по маске подсети. Срез идёт до второго символа, не включая его

IP_STR_BIN = IP_STR_BIN[0:Mask]

# Дописываем строку IP нулями.
# Так мы преобразовали адрес хоста в адрес сети.

IP_STR_BIN = IP_STR_BIN + (32 - Mask) * '0'

# На основе строки IP составляем список IP

IP_LIST = [IP_STR_BIN[0:8], IP_STR_BIN[8:16], IP_STR_BIN[16:24], IP_STR_BIN[24::]]

# Преобразуем текстовые значения в цифровые (стр. 131)

IP_LIST = [int(IP_LIST[I], 2) for I in range(4)]

#--------------------------------------------------------------------

# Создаём образец для вывода IP (см. стр. 101)

ip_template = '''
    ...: Network
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:08b} {1:08b} {2:08b} {3:08b}
    ...: '''

# Выводим

print(ip_template.format(IP_LIST[0], IP_LIST[1], IP_LIST[2], IP_LIST[3]))

# Опять получаем строковое значение битовой маски
# на этот раз с символом "/"

Mask = NetMask[NetMask.find('/')::]

# Создаём образец для вывода Mask

mask_template_bit = '''
    ...: Mask:
    ...: {}'''


mask_template = '''
    ...: {0:<8} {1:<8} {2:<8} {3:<8}
    ...: {0:8b} {1:08b} {2:08b} {3:08b}
    ...: '''

# Выводим
# Метод lstrip('\n') удалит новую строку перед выводом двоичного и десятичного
# значений маски. Если этого не сделать, появиться не нужная пустая строка
# между mask_template_bit и mask_template. См. стр. 97

print(mask_template_bit.format(Mask))
print(mask_template.format(MaskList[0], MaskList[1], MaskList[2], MaskList[3]).lstrip('\n'))

############
############
